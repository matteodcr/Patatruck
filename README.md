# GPI & PLA : Le patatruck

[![](https://img.shields.io/badge/gitlab-patatruck-orange)](https://gricad-gitlab.univ-grenoble-alpes.fr/PROJET_INFO3/G1/patatruck)

Concept de base: un food-truck qui cuisine ses plats pendant qu'il se rend sur le lieu de livraison. Un joueur s'occupe de cuisiner les plats tandis que le second conduit le vÃ©hicule. L'aggressivitÃ© de la conduite peut se faire sentir dans la cuisine tandis que les erreurs en cuisine auront des rÃ©percussions sur le conduite.

La cuisine en question https://www.youtube.com/watch?v=LgOyYzm33dw

![illustration conceptuelle](https://media.discordapp.net/attachments/980722135058243647/981831202539446272/fritent.png?width=794&height=447)
_Illustration conceptuelle: la cuisine manque et les compteurs de part et d'autre du camion pourraient changer_

## Contraintes du projet

  * Deux joueurs: un conducteur, un cuisinier
  * Deux mondes avec des physiques diffÃ©rentes: la ville vue de haut en plan large avec une physique de conduite (inertie, accÃ©lÃ©ration), la cuisine du camion (mouvements basiques sur une grille)
      * Des mondes qui intÃ©ragissent: le camion ramasse des ingrÃ©dients sur la route, l'accÃ©lÃ©ration du camion (positive ou nÃ©gative) peut pÃ©naliser la cuisine
  * Des entitÃ©s qui pululent: des cafards dans la cuisine (rare, mais ennuyeux), des piÃ©tons, des voitures dans la ville
  * Un des mondes est infini: la ville est gÃ©nÃ©rÃ©e procÃ©duralement

## IngrÃ©dients / Recettes
![](https://md.edgar.bzh/uploads/upload_524dc869caa95794e7108d0c321d82ae.png)


## Scoring / conditions de fin

* 3 minutes de temps au dÃ©but
* Une commande livrÃ©e = rajoute du temps
* Score = temps que l'on rÃ©ussit Ã  survivre
* Game over si timer arrive Ã  0 +

## Plan du patatruck (cuisine)
![](https://md.edgar.bzh/uploads/upload_e85fdd9d29f6de1685d7d527abaa0043.png)

**Tables Ã  sauce :** Contient de la sauce qu'on considÃ¨re en quantitÃ© illimitÃ©e
**IngrÃ©dients :** Contient un type d'ingrÃ©dient qu'on possÃ¨de en quantitÃ© limitÃ©e. On peut ramasser les ingrÃ©dients sur la route
**Planches Ã  dÃ©couper :** Permet de dÃ©couper certains ingrÃ©dients qui peuvent Ãªtre dÃ©coupÃ©s (patates, tomates, pain)
**Friteuses :** Permet de faire frire les patates dÃ©coupÃ©es
**Feux de cuisson :** Permet de faire cuire la viande et les patates dÃ©coupÃ©es
**Poubelle :** Permet de jeter un ingrÃ©dient (en cas d'erreur par exemple)
**Tables :** Permet de dÃ©poser un ingrÃ©dient dessus
**Livraison :** On peut dÃ©poser n'importe quel item sur chaque bac Ã  livraison. Le camion se trouve Ã  l'endroit de livraison prÃ©vu, les ingrÃ©dients disparaissent et la recette est validÃ©e, on en obtient une nouvelle

https://docs.google.com/spreadsheets/d/1Ua8SwKIQYQbvkAa6IYdM2cNQfL4THITyxEKHs4Gwb-M/edit?usp=sharing

##  Tuiles de route

GÃ©nÃ©rÃ©es procÃ©duralement. Viewport centrÃ© sur le camion. La grille est une alternance de cellules 11x11 et 9x9 en diagonale (avec des cellules 9x11 et 11x9 qui les relient).

  * Les cellules 11x11 correspondent forcÃ©ment Ã  un bÃ¢timent, et sont donc forcÃ©ment pleines.
  * Les cellules dont un cÃ´tÃ© fait 9 pixels et l'autre 11 correspondent oÃ¹ bien Ã  des routes, ou bien Ã  des connexions entre deux bÃ¢timents (pour former un bÃ¢timent plus grand). Leur Ã©tat est dÃ©terminÃ© par le gÃ©nÃ©rateur procÃ©dural.
  * Les cellules 9x9 correspondent Ã  des croisement entre des routes, ou bien Ã  des connexions entre des bÃ¢timents si les 4 cellules l'entourant sont Ã©galement des connexions entre des bÃ¢timents. Leur Ã©tat est donc dÃ©rivÃ©.

Pour rÃ©sumer, seul l'Ã©tat des cellules 9x11 et 11x9 a besoin d'Ãªtre gÃ©nÃ©rÃ©, les Ã©tats des autres cellules sont constants ou dÃ©rivÃ©s. L'algorithme de gÃ©nÃ©ration est en cours de conception.

ElÃ©ments de la ville :

  * BÃ¢timents (alignÃ©s sur la grille) :
      * CarrÃ© 1x1
      * CarrÃ© 2x2
      * Ligne droite 2x1 (vertical & horizontal)
      * Ligne droite 3x1 (vertical & horizontal)
      * "L" 2x2 (bas-droite, bas-gauche, haut-gauche, haut-droite)
      * _Certains ont plusieurs variantes visuelles_
  * EntitÃ©s
      * Plots de signalisation
      * Etals de marchÃ© : donnent des resources lors d'une collision avec un vÃ©hicule
      * Ralentisseurs : mÃ©lange les items dans le camion
      * Verglas : change la physique du camion
      * Nid de poule : Ã©change le conducteur et le cuisinier
      * Si ralentisseur trop rapide + item par terre dans camion : impacte la vision de la route

## Automates/entitÃ©s dans le camion

[ðŸ’¬ SÃ©mantique du langage](https://gricad-gitlab.univ-grenoble-alpes.fr/PROJET_INFO3/projet/-/blob/master/gal/SEMANTIQUE.md)

#### Cafards
``` haskell
Cafard(DeplacementN){
 * (DeplacementN): 						
 | Cell(H,@) 	? Explode() :()				//Le cafard regarde si le joueur est sur sa case, si oui il meurt
 | Cell(N,@) 	? :(DeplacementS)				//Le cafard regarde si le joueur est sur la case nord, si oui il se dÃ©place vers le sud pour l'Ã©viter
 | Cell(H,P)	? 4%Pick(H) / 48%Pop / 48%Wizz  :(_)		//Le cafard regarde si la case actuelle contient un pickable, si oui il a 4% de chances de le prendre
 | Cell(N,V/A)	? Move(N) :(_)					//Le cafard regarde si la case nord est vide ou possÃ¨de un cafard, il se dÃ©place vers le nord
 | True      	? Turn(S) :(_)					//Dans ce cas lÃ , le cafard ne pourra pas avancer vers le nord et se tourne vers le sud
 
 * (DeplacementS): 
 | Cell(S,@) 	? Explode() :()				//Le cafard regarde si le joueur est sur sa case, si oui il meurt
 | Cell(S,@)	? :(DeplacementN)				//Le cafard regarde si le joueur est sur la case sud, si oui il se dÃ©place vers le nord pour l'Ã©viter
 | Cell(H,P)	? 4%Pick(H) / 48%Pop / 48%Wizz  :(_)		//Le cafard regarde si la case actuelle contient un pickable, si oui il a 4% de chances de le prendre
 | Cell(S,V/A)	? Move(S) :(_)					//Le cafard regarde si la case sud est vide ou possÃ¨de un cafard, si oui il se dÃ©place vers le sud
 | True      	? Turn(N) :(_)					//Dans ce cas lÃ , le cafard ne pourra pas avancer vers le sud et se tourne vers le nord
 
 * (DeplacementE): 
 | Cell(H,@)	? Explode() :()				//Le cafard regarde si le joueur est sur sa case, si oui il meurt
 | Cell(E,@)	? :(DeplacementR)				//Le cafard regarde si le joueur est sur la case Est, si oui il se dÃ©place vers l'ouest pour l'Ã©viter
 | Cell(H,P)	? 4%Pick(H) / 48%Pop / 48%Wizz  :(_)		//Le cafard regarde si la case actuelle contient un pickable, si oui il a 4% de chances de le prendre
 | Cell(E,V/A)	? Move(E) :(_)					//Le cafard regarde si la case Est est vide ou possÃ¨de un cafard, si oui il se dÃ©place vers l'est
 | True    	? Turn(W) :(_)					//Dans ce cas lÃ , le cafard ne pourra pas avancer vers l'Est et se tourne vers l'ouest
 
 * (DeplacementW): 
 | Cell(H,@)	? Explode() :()				//Le cafard regarde si le joueur est sur sa case, si oui il meurt
 | Cell(W,@)	? :(DeplacementL)				//Le cafard regarde si le joueur est sur la case ouest, si oui il se dÃ©place vers l'Est pour l'Ã©viter
 | Cell(H,P)	? 4%Pick(H) / 48%Pop / 48%Wizz  :(_)		//Le cafard regarde si la case actuelle contient un pickable, si oui il a 4% de chances de le prendre
 | Cell(W,V/A)	? Move(W) :(_)					//Le cafard regarde si la case ouest est vide ou possÃ¨de un cafard, si oui il se dÃ©place vers l'ouest
 | True     	? Turn(E) :(_)					//Dans ce cas lÃ , le cafard ne pourra pas avancer vers l'ouest et se tourne vers l'Est
 
 * (Dupplication): 
 | True ? 10%Egg(H) / 40%Pop / 40%Wizz :(_)			//Le cafard Ã  10% de chances de se duppliquer, sinon il fait des annimations graphiques
  
 * ()
 }
 Pop et Wizz sont des animations graphiques
```
#### Equipement cuisine 

```haskell
Feu_cuisson(wait){
    *(wait)
    |Cell(H,P) ? Pop:(cook)            //Si un objet pickable est sur la mÃªme case, un Pop va afficher un sprite en mode "feu allumÃ©"
    |Cell(H,V) ?    :(wait)            //Si il n'y a aucune objet sur la mÃªme case, on attends
    
    *(cook)
    |True ?     wait:(cuit)            //On effectue un wait, ce qui correspond au temps de cuisson

    *(cuit)
    |Cell(H,P) ?    :(cuit)            //Tant que l'Ã©lÃ©ment pickable est encore prÃ©sent, on boucle sur cet Ã©tat
    |Cell(H,V) ?    Wizz:(wait)        //Si l'Ã©lÃ©ment n'est plus prÃ©sent, le Wizz va afficher un sprite en mode "feu Ã©teint"
}

Friteuse(wait){
    *(wait)
    |Cell(H,P) ? Pop:(cook)            //Si un objet pickable est sur la mÃªme case, un Pop va afficher un sprite en mode "huile chaude"
    |Cell(H,V) ?    :(wait)            //Si il n'y a aucune objet sur la mÃªme case, on attends
    
    *(cook)
    |True ?     wait:(cuit)            //On effectue un wait, ce qui correspond au temps de cuisson

    *(cuit)
    |Cell(H,P) ?    :(cuit)            //Tant que l'Ã©lÃ©ment pickable est encore prÃ©sent, on boucle sur cet Ã©tat
    |Cell(H,V) ?    Wizz:(wait)        //Si l'Ã©lÃ©ment n'est plus prÃ©sent, le Wizz va afficher un sprite en mode "huile froide"
}

Garde_manger(wait){
    *(wait)
    |Cell(H,V) & GotStuff ?    Wizz:(waitRestock)    //Si la cellule est vide et qu'il reste du stuff on passe dans l'Ã©tat restock qui va remettre un item sur le prÃ©sentoire du garde manger
    |True ?    :(wait)                               //rien dans l'inventaire du G_m
    
    *(waitRestock)                        
    |True ? wait:(restock)                           //tps d'attente avant de pouvoir repick un item
    
    *(restock)                     
    |True ? Pop:(wait)                               //On repasse dans l'Ã©tat wait avec un Pop qui affiche un item sur le prÃ©sentoire
}

Table(vide){
    *(vide)
    |Cell(H,P) ? Pop:(pleine)        //Si pickable here => Ã©tat pleine, Pop changement de sprite mode "table pleine"
    |Cell(H,V) ?    :(vide)         //Si void here => Ã©tat vide
    
    *(pleine)
    |Cell(H,P) ?    :(pleine)        //Si pickable here => Ã©tat pleine
    |Cell(H,V) ? Wizz:(vide)        //Si void here => Ã©tat vide, Wizz changement de sprite mode "table vide"
}

Table_a_sauce(ready){
    *(ready)
    |GotPower ? Wizz:(waitRestock)    //S'il y a une interaction, Wizz changement de sprite mode "reload"
    |True ?   :(ready)               //Sinon on reste dans l'Ã©tat ready
        
    *(waitRestock)                        
    |True ? wait:(restock)          //tps d'attente avant le reload
    
    *(restock)                     
    |True ? Pop:(ready)             //On repasse dans l'Ã©tat ready avec un Pop changement de sprite mode "table ready"
}
GotPower sera implÃ©mentÃ© comme ceci
True=>interaction
False=>!interaction

Planche(vide){
    *(vide)
    |Cell(H,P) ? Pop:(startCoupe)                             //S'il y a un Ã©lÃ©ment pickable on passe dans l'Ã©tat startCoupe
    |Cell(H,V) ?    :(vide)                                   //S'il n'y a pas d'item on boucle dans l'Ã©tat vide
    
    *(startCoupe)
    |Cell(H,P) & Key(SPACE) & Cell(F,@) ? Hit: (couper1)       //Si l'Ã©lÃ©ment pickable est toujours prÃ©sent, que le joueur est en face de la planche et qu'il appuye sur la touche ESPACE, on compte une dÃ©coupe
    |True ?    :(startCoupe)                                   //Boucle sur l'Ã©tat actuel si le joueur ne dÃ©coupe pas
    
    *(couper1)
    |Cell(H,P) & Key(SPACE) & Cell(F,@) ? Hit: (couper2)       //Si l'Ã©lÃ©ment pickable est toujours prÃ©sent, que le joueur est en face de la planche et qu'il appuye sur la touche ESPACE, on compte une dÃ©coupe supplÃ©mentaire
    |True ?    :(couper1)                                      //Boucle sur l'Ã©tat actuel si le joueur ne dÃ©coupe pas
    
    *(couper2)
    |Cell(H,P) & Key(SPACE) & Cell(F,@) ? Hit: (couper)        //Si l'Ã©lÃ©ment pickable est toujours prÃ©sent, que le joueur est en face de la planche et qu'il appuye sur la touche ESPACE, on compte une dÃ©coupe supplÃ©mentaire
    |True ?    :(couper2)                                      //Boucle sur l'Ã©tat actuel si le joueur ne dÃ©coupe pas
    
    *(couper)
    |Cell(H,V) ? Wizz:(vide)                                   //L'Ã©lement Ã  fini d'Ãªtre dÃ©coupÃ©, on repasse dans l'Ã©tat vide
    |True ?    :(couper)                                      //Tant que le joueur ne rÃ©cupÃ¨re pas l'Ã©lÃ©ment, on boucle dans cet Ã©tat
}

Livraison(vide){
    *(vide)
    |Cell(H,P) ? Pop:(pret) // si on detecte un pickable dessus, on passe en plein
    |Cell(H,V) ?    :(vide) // sinon on attends
    
    *(pret)
    |Cell(H,P) ? Wizz:(vide) // c'est bon on supprime l'Ã©lÃ©ment
    |True ?          :(vide)
}

```

#### Cuisinier
```haskell
Cook(Init){
  * (Init):
  | Key(Z) ? Wizz(N):(Init)
  | Key(Q) ? Wizz(E):(Init)
  | Key(S) ? Wizz(O):(Init)
  | Key(D) ? Wizz(S):(Init)
  | Key(SPACE) ? Pop(F):(Init)  
}
```
## Automates/entitÃ©s sur la route

#### Camion

```haskell
Truck(Init){
  * (Init):
  | Key(FU) ? Wizz(N):(Init)
  | Key(FD) ? Wizz(S):(Init)
  | Key(FL) ? Wizz(O):(Init)
  | Key(FR) ? Wizz(E):(Init)
  | Key(ENTER) ? Pop(F):(Init)
}
```

#### Voitures
```haskell
Voiture(Drive) { -- Route : Jumpable; Croisement : Gate; Autre : Obstacle
    * (Drive) 
    | Cell(_,@) ? Pop :(Stop) -- Contact avec le camion => Stop
    | Cell(F,O) & Cell(R,J) ? Move(R) :(Roule) -- Mur devant + libre Ã  droite 
                                               -- => droite
    | Cell(F,O) & Cell(L,J) ? Move(L) :(Roule) -- Mur devant + libre Ã  gauche 
                                               -- => gauche
    | Cell(H,G) ? 10%Move(R) / 10%Move(L) / Move(F) :(Roule) -- Croisement
    | True ? Move(F) :(Roule) -- Avancer

    * (Stop) 
    | Cell(_,@) ? :(Stop)  -- Contact avec le camion => Stop
    | True ? Wizz :(Roule) -- Plus de contact => Drive
}
```
#### Stand de marchÃ© 

```haskell
MarchÃ©(Still){
  * (Still) 
  | Cell(_,@) ? Pop  :()
  | True ? Wizz :(Still)
  * ()
}
```

#### CÃ´ne de signalisation autour du marchÃ©
```haskell
TrafficCone(Still) {
  * (Still):
  | Cell(H,_) ? Pop :()
  | True ? Wizz :(Still)
  * ()
}
```
<BLOCKQUOTE>
Le cone ne fait rien mais se dÃ©truit s'il touche une autre entitÃ©.
</BLOCKQUOTE>

#### Ralentisseur

```haskell
SpeedBump(Still) {
    * (Still):
    | Cell(H,@) ? Pop :(Still) //verif si joueur passÃ© trop vite
    | True ? Wizz :(Still) //nothing
}
```

#### Nid de poule

```haskell
Pothole(Still) {
    * (Still):
    | Cell(H,@) ? Pop :(Still) //verif si joueur passÃ© dessus
    | True ? Wizz :(Still) //nothing
}
```

#### Verglas

```haskell
Iced_road(Still) {
    * (Still):
    | Cell(H,@) ? Pop :(Still) //verif si joueur passÃ© dessus
    | True ? Wizz :(Still) //nothing
}
```

#### (PiÃ©ton ?)

:::info
BONUS
:::

## Effet de la cuisine sur la conduite = Doublure

Chaque erreur sur la cuisson aura un impact sur la conduite = on change le stunt associÃ© Ã  l'entitÃ© camion 
* Erreur de friture : flaque d'huile donc plus de freins
* Erreur sur la cuisson de la viande : fumÃ©e donc obligÃ© d'aller doucement (ralentit)

## Planning

```mermaid
gantt
title Orga
dateFormat DD/MM/YY
axisFormat  %d/%m/%Y

section Travail
Faire une Ã©quipe :done, 02/06/22, 1d
Faire des automates :active, 08/06/22, 21d
Coder le jeu :13/06/22, 1d
Tester le jeu :crit, 13/06/22, 3d

section Divertissement
PrÃ©parer le cafÃ©: 01/06/22,30/06/22
Faire la fÃªte: milestone,15/06/22
```

## Journal

## 4-7 juin

  * Travail sur le diagramme UML
  * Choix du concept et dÃ©but conception

## 7 juin

Travail personnel :
  * RÃ©flexion sur le contenu du jeu
      * Cuisine
      * Hitboxes et collisions
  * Ecriture de plusieurs automates pour prendre de l'avance et se familiariser avec la syntaxe
  * Mise en place du dÃ©pÃ´t
  * RÃ©daction du README

En groupe: Election du chef d'Ã©quipe
